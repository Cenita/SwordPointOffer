## 14剪绳子
**题目描述**
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

---
**输入输出**
>输入:  10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

>输入:  2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

---
**解决方案**
1. 直接使用动态规划将剪绳子划分成子问题，时间空间复杂度O(n)
>条件1 如果长度为2的绳子则剪两段，答案是1
>条件2 如果长度为3的绳子剪两段，答案是2
>条件3 如果长度>3的绳子，剪两段分别是i和n-i段，i段还可以继续剪两段，最优值在已经剪完的里面比较，是自己不剪大还是剪两段大，就可以写个式子f(n) = max(f(i),f(n-i),n)
```java
   public static int cuttingRope(int n) {
       //特殊情况两种,因为必须得剪，所以这是剪之后的最优值
       if(n==2) return 1;
       if(n==3) return 2;
       int[] dp = new int[n+1];
       //对于子段可剪可不剪，段2选择不剪最好，段3选择不剪最好
       dp[1]=1;
       dp[2]=2;
       dp[3]=3;
       for(int i=4;i<=n;i++){
           int max = i;
           for(int j=1;j<i;j++){
               if(dp[j]*dp[i-j]>max){
                   //比较最大值
                   max = dp[j]*dp[i-j];
               }
           }
           dp[i]=max;
       }
       return dp[n];
   }
```

2. 贪心算法 - 时间空间都O(1)
```cpp
//--->
n     乘积     子数字
2       1       1 1
3       2       1 2
4       4       2 2
5       6       2 3
6       9       3 3
7       12      2 2 3
8       18      2 3 3
9       27      3 3 3
10      36      2 2 3 3
11      54      2 3 3 3
12      81      3 3 3 3
13      108     2 2 3 3 3
14      162     2 3 3 3 3
15      243     3 3 3 3 3
16      324     2 2 3 3 3 3
17      486     2 3 3 3 3 3
18      729     3 3 3 3 3 3
19      972     2 2 3 3 3 3 3
20      1458    2 3 3 3 3 3 3
21      2187    3 3 3 3 3 3 3
22      2916    2 2 3 3 3 3 3 3
23      4374    2 3 3 3 3 3 3 3
24      6561    3 3 3 3 3 3 3 3
25      8748    2 2 3 3 3 3 3 3 3
26      13122   2 3 3 3 3 3 3 3 3
27      19683   3 3 3 3 3 3 3 3 3
28      26244   2 2 3 3 3 3 3 3 3 3
29      39366   2 3 3 3 3 3 3 3 3 3
```
根据数论可知，尽量切成3长度，如果剩余4则切成2*2，如果剩余2就切成2
```java
  public static int cuttingRope(int n) {
      if(n<2) return 0;
      if(n==2) return 1;
      if(n==3) return 2;
      int threeNum = n/3;
      //答案为4的情况
      if(n%3==1) threeNum-=1;
      int timeOf2 = (n-threeNum*3)/2;
      long result = 1;
      while(n>4){
          result*=3;
          result%=1000000007;
          n-=3;
      }
      if(n==4) result*=2*2;
      if(n==3) result*=3;
      if(n==2) result*=2;
      return (int)(result%=1000000007);
  }
```
