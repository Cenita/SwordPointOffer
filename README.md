## 剑指Offer 算法题整理汇总

**简介**

剑指Offer中所有的面试题，建议一边看书一边来[LeetCode](https://leetcode-cn.com/problemset/lcof/)上做

本算法题汇总只提炼重要的解析，如果希望明白其中的算法思路建议看LeetCode或书上的解析

适合复习剑指Offer的同学，简要指出其知识点

如果你需要Java代码，可访问源码地址Clone下
[源码](https://github.com/Cenita/SwordPointOffer/tree/master/code)。


建议复习的时候先看题目然后思考解决方法

如果忘记则打开链接中的答案来看答案。
  
  ---
[03数组中重复的数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.md)

**题目描述**
>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例**
>输入：[2, 3, 1, 0, 2, 5, 3]
>输出：2或3
 
 ---
[04二维数组中的查找](https://github.com/Cenita/SwordPointOffer/blob/master/note/04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md)
 
 **题目描述**
>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
**限制：**
`0 <= n <= 1000`
`0 <= m <= 1000`

**示例**
```python
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
>给定 target = 5，返回 true。
给定 target = 20，返回 false。
 
 ----
[05替换空格](https://github.com/Cenita/SwordPointOffer/blob/master/note/05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md)

**题目描述**
>请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例**
>输入：s = "We are happy."
输出："We%20are%20happy."
  
 ----
[06从尾到头打印链表](https://github.com/Cenita/SwordPointOffer/blob/master/note/06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md)

**题目描述**
>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例**
>输入：head = [1,3,2]
输出：[2,3,1]
 
 ---- 
[07重建二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md)
  
**题目描述**
> 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

**示例**
>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回
```
    3
   / \
  9  20
    /  \
   15   7
```

----
[09双栈变队列](https://github.com/Cenita/SwordPointOffer/blob/master/note/09%E5%8F%8C%E6%A0%88%E5%8F%98%E9%98%9F%E5%88%97.md)

**题目描述**
>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

**示例**
>输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
 
 ----
[10斐波那契数列](https://github.com/Cenita/SwordPointOffer/blob/master/note/10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.md)
  
**题目描述**
>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例**
>输入：n = 5
输出：5

---
[11旋转数组的最小数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md)

**题目描述**
>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 要求时间复杂度使用O(logN) 

**示例**
>输入：[3,4,5,1,2]
输出：1

>输入：[2,2,2,0,1]
输出：0

---
[12矩阵中的路径](https://github.com/Cenita/SwordPointOffer/blob/master/note/12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.md)

**题目描述**
>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]
但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

**示例**
>输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

>输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false

---
[13机器人的运动范围](https://github.com/Cenita/SwordPointOffer/blob/master/note/13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.md)

**题目描述**
>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例**
>输入：m = 2, n = 3, k = 1
输出：3

>输入：m = 3, n = 1, k = 0
输出：1

>输入：m = 38, n = 15, k = 9
输出：135


---
[14剪绳子](https://github.com/Cenita/SwordPointOffer/blob/master/note/14剪绳子.md)

**题目描述**
>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例**
>输入:  10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

>输入:  2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

---
[15Excle序号转化进制附加题](https://github.com/Cenita/SwordPointOffer/blob/master/note/15Excle序号转化进制附加题.md)

**题目描述**
>给定一个Excel表格中的列名称，返回其相应的列序号。
例如，
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

**示例**
>**输入:** "A"
**输出:** 1

>**输入:** "AB"
**输出:** 28

>**输入:** "ZY"
**输出:** 701

---
[15二进制中1的个数](https://github.com/Cenita/SwordPointOffer/blob/master/note/15二进制中1的个数.md)

**题目描述**
>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

**示例**
>输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

---
[16数值的整数次方](https://github.com/Cenita/SwordPointOffer/blob/master/note/16数值的整数次方.md)
  

**题目描述**
>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

**示例**
>**输入:** 2.00000, -2
**输出:** 0.25000
**解释:** 2-2 = 1/22 = 1/4 = 0.25

>**输入:** 2.10000, 3
**输出:** 9.26100

---
[17打印从1到最大的n个位数](https://github.com/Cenita/SwordPointOffer/blob/master/note/17打印从1到最大的n个位数.md)

**题目描述**
>输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**示例**
>输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]

---
[18删除链表的节点](https://github.com/Cenita/SwordPointOffer/blob/master/note/18删除链表的节点.md)

**题目描述**
>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。

**示例**
>输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.

>输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

---
[19正则表达式匹配](https://github.com/Cenita/SwordPointOffer/blob/master/note/19正则表达式匹配.md)
 
**题目描述**
>请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

**示例**
>**输入:**
s = "ab"
p = ".*"
**输出:** true
**解释:** ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

---

[20表示数值的字符串](https://github.com/Cenita/SwordPointOffer/blob/master/note/20表示数值的字符串.md)


**题目描述**
>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

**输入输出**
>+100
>true

---
[21调整数组顺序使奇数位于偶数前面](https://github.com/Cenita/SwordPointOffer/blob/master/note/21调整数组顺序使奇数位于偶数前面.md)

**题目描述**
>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

---
**示例**
>输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。

---
[22链表中倒数第k个结点](https://github.com/Cenita/SwordPointOffer/blob/master/note/22链表中倒数第k个结点.md)

**题目描述**
>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

**示例**
>给定一个链表: 1->2->3->4->5, 和 _k_ = 2.
>返回链表 4->5.
>
---



[23链表中环的入口](https://github.com/Cenita/SwordPointOffer/blob/master/note/23链表中环的入口.md)
 
**题目描述**
>如果一个链表中包含环，如何找出环的入口结点？


**示例**
>1->2->3->4->5->6，然后6指向3形成环
>输出3为环入口

----
[24翻转链表](https://github.com/Cenita/SwordPointOffer/blob/master/note/24翻转链表.md)
  
**题目描述**
>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例**
>**输入:** 1->2->3->4->5->NULL
**输出:** 5->4->3->2->1->NULL

---
[25合并两个排序的链表](https://github.com/Cenita/SwordPointOffer/blob/master/note/25合并两个排序的链表.md)
  

**题目描述**
>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**输入输出**
>输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

----



[26树的子结构](https://github.com/Cenita/SwordPointOffer/blob/master/note/26树的子结构.md)
  

**题目描述**
>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。

**输入输出**
>输入：A = [1,2,3], B = [3,1]
输出：false

---
[27二叉树的镜像](https://github.com/Cenita/SwordPointOffer/blob/master/note/27二叉树的镜像.md)

**题目描述**
>请完成一个函数，输入一个二叉树，该函数输出它的镜像。

**输入输出**

		   4  
		  / \  
		 2   7  
		/ \ / \  
		1 3 6 9

		   4  
		  / \  
		 7   2  
		/ \ / \  
		9 6 3 1


---

[28对称的二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/28对称的二叉树.md)

**题目描述**
>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

	    1
	   / \
	  2   2
	 / \ / \ 
	3  4 4  3
>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

	   1
	   /\ 
	  2  2
	   \  \ 
	   3   3

**输入输出**
>输入：root = [1,2,2,3,4,4,3]
输出：true

---

[29顺时针打印矩阵](https://github.com/Cenita/SwordPointOffer/blob/master/note/29顺时针打印矩阵.md)
  
**题目描述**
>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

**输入输出**
>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

---
[30包含Min函数的栈](https://github.com/Cenita/SwordPointOffer/blob/master/note/30包含Min函数的栈.md)

**题目描述**
>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

---
[31栈的压入弹出序列](https://github.com/Cenita/SwordPointOffer/blob/master/note/31栈的压入弹出序列.md)
  
**题目描述**
>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

**输入输出**
>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。


---
[32从上到下打印二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/32从上到下打印二叉树.md)

**题目描述**
>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

**样例**
>给定二叉树: [3,9,20,null,null,15,7],

	    3
	    /\ 
	   9  20
	     / \ 
	    15 7
>返回：
[3,9,20,15,7] 


---



[32-2分行从上到下打印二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/32-2分行从上到下打印二叉树.md)
  
**题目描述**
>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

 

**输入输出**
>给定二叉树: [3,9,20,null,null,15,7],

	   3
	   /\ 
	  9  20
	    / \ 
	   15   7
>返回其层次遍历结果：

	[
	  [3],
	  [9,20],
	  [15,7]
	]





----
[32-3之形从上到下打印二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/32-3之形从上到下打印二叉树.md)
  

**题目描述**
>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。


**输入输出**
>给定二叉树: [3,9,20,null,null,15,7],

	   3
	   /\ 
	  9  20
	    / \ 
	   15   7
>返回其层次遍历结果：

	[
	  [3],
	  [20,9],
	  [15,7]
	]



---
[33二叉搜索树的后序遍历](https://github.com/Cenita/SwordPointOffer/blob/master/note/33二叉搜索树的后序遍历.md)



**题目描述**
>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
参考以下这颗二叉搜索树：

        5
       / \
      2   6
     / \
    1   3

**输入输出**
>**输入:** [1,6,3,2,5]
**输出:** false

>**输入:** [1,3,2,6,5]
**输出:** true



---
  
[34二叉树中和为某一值的路径](https://github.com/Cenita/SwordPointOffer/blob/master/note/34二叉树中和为某一值的路径.md)
  

**题目描述**
>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

**输入输出**
>示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
>返回:
[
         [5,4,11,2],
        [5,8,4,5]
]






---
[35复杂链表的复制](https://github.com/Cenita/SwordPointOffer/blob/master/note/35复杂链表的复制.md)
 

**题目描述**
>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

**输入输出**
>示例 1：
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

>示例 2：
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
>输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

>示例 3：
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)
>输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]

>示例 4：
>输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。






---
[36二叉搜索树与双向链表](https://github.com/Cenita/SwordPointOffer/blob/master/note/36二叉搜索树与双向链表.md)
  
**题目描述**
>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
为了让您更好地理解问题，以下面的二叉搜索树为例：
![输入图片描述](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
![输入图片描述](https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png)
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。


---
[37序列化二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/37序列化二叉树.md)
  
**题目描述**
>请实现两个函数，分别用来序列化和反序列化二叉树。

**输入输出**
>你可以将以下二叉树：

	     1
	    / \
	    2   3
	       / \
	      4   5

>序列化为 "[1,2,3,null,null,4,5]"



---
[38字符串的排雷](https://github.com/Cenita/SwordPointOffer/blob/master/note/38字符串的排雷.md)
  
**题目描述**
>输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

**输入输出**
>**输入：**s = "abc"
**输出：[**"abc","acb","bac","bca","cab","cba"**]**




---
[39数组中出现次数超过一半的数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/39数组中出现次数超过一半的数字.md)
  

**题目描述**
>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**输入输出**
>**输入:** [1, 2, 3, 2, 2, 2, 5, 4, 2]
**输出:** 2




---
[40最小的k个数](https://github.com/Cenita/SwordPointOffer/blob/master/note/40最小的k个数.md)


**题目描述**
>输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

**输入输出**
>**输入**arr = [3,2,1], k = 2
**输出：**[1,2] 或者 [2,1]

>**输入**arr = [0,1,2,1], k = 1
**输出：**[0]




---
[41数据流中中位数](https://github.com/Cenita/SwordPointOffer/blob/master/note/41数据流中中位数.md)

**题目描述**
>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
```java
class MedianFinder {
    /** initialize your data structure here. */
    public MedianFinder() {
    }
    public void addNum(int num) {
    }
    public double findMedian() {
    }
}
/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

**输入输出**
>输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]

>输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]





---
[42连续子数组最大和](https://github.com/Cenita/SwordPointOffer/blob/master/note/42连续子数组最大和.md)

**题目描述**
>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。

**输入输出**
>**输入:** nums = [-2,1,-3,4,-1,2,1,-5,4]
**输出:** 6
**解释:** 连续子数组 [4,-1,2,1] 的和最大，为 6。

---
[43-1~n整数中1的个数](https://github.com/Cenita/SwordPointOffer/blob/master/note/43-1~n整数中1的个数.md)

**题目描述**
>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

**输入输出**
>**输入**n = 12
**输出**5

>**输入**n = 100
**输出**21

---





[44数列中某一位数组](https://github.com/Cenita/SwordPointOffer/blob/master/note/44数列中某一位数组.md)



**题目描述**
>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。

**输入输出**
>**输入**n = 11
**输出**0
---





[45把数组排成最小的数](https://github.com/Cenita/SwordPointOffer/blob/master/note/45把数组排成最小的数.md)


**题目描述**
>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

**输入输出**
>**输入:** `[10,2]`
**输出:** "`102"`

>**输入:** `[3,30,34,5,9]`
**输出:** "`3033459"`


---

[46把数字翻译成字符串](https://github.com/Cenita/SwordPointOffer/blob/master/note/46把数字翻译成字符串.md)

**题目描述**
>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

**输入输出**
>**输入:** 12258
**输出:** `5` 
**解释:** 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
---





[47礼物的最大价值](https://github.com/Cenita/SwordPointOffer/blob/master/note/47礼物的最大价值.md)

**题目描述**
>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

**输入输出**
>输入如下矩阵
```python
	[
	  [1,3,1],
	  [1,5,1],
	  [4,2,1]
	]
```
>输出: `12`
>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

---







[48最长不含重复字符的子字符串](https://github.com/Cenita/SwordPointOffer/blob/master/note/48最长不含重复字符的子字符串.md)


**题目描述**
>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

**输入输出**
>输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 `"abc"，所以其`长度为 3。

>输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。

>输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。



---
[49丑数](https://github.com/Cenita/SwordPointOffer/blob/master/note/49丑数.md)


**题目描述**
>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**输入输出**
>**输入:** n = 10
**输出:** 12
**解释:** `1, 2, 3, 4, 5, 6, 8, 9, 10, 12` 是前 10 个丑数。
---





[50第一个只出现一次的字符](https://github.com/Cenita/SwordPointOffer/blob/master/note/50第一个只出现一次的字符.md)


**题目描述**
>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**输入输出**
>s = "abaccdeff"
返回 "b"

>s = "" 
返回 " "

---



[51数组中逆序对](https://github.com/Cenita/SwordPointOffer/blob/master/note/51数组中逆序对.md)

**题目描述**
>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**输入输出**
>**输入**: [7,5,6,4]
**输出**: 5
---






[52两个链表的第一个公共结点](https://github.com/Cenita/SwordPointOffer/blob/master/note/52两个链表的第一个公共结点.md)

**题目描述**
>输入两个链表，找出它们的第一个公共节点。
如下面的两个链表
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

**输入输出**
 
  
>样例1
>![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)
>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

>样例2
>
>![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)
>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

>样例3
>![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)
>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

---






[53数组中数值和下标相等的元素](https://github.com/Cenita/SwordPointOffer/blob/master/note/53数组中数值和下标相等的元素.md)




**题目描述**
>假设一个单调递增的数组里有每个元素都是整数并且是唯一的，请变成实现一个函数，找出数组中任意一个数值等于其下标的元素。要求时间O(logN)

**输入输出**
>输入：{-3,-1,1,3,5}
>输出：3
>解释：3和其下标位置相等

---
[53在排序数组中查找数字 I](https://github.com/Cenita/SwordPointOffer/blob/master/note/53在排序数组中查找数字%20I.md)

**题目描述**
>统计一个数字在排序数组中出现的次数。
在O(logN)的时间复杂度内完成

**输入输出**
>**输入:** nums = [`5,7,7,8,8,10]`, target = 8
**输出:** 2

>**输入:** nums = [`5,7,7,8,8,10]`, target = 6
**输出:** 0
---
[53 0～n-1中缺失的数字- II](https://github.com/Cenita/SwordPointOffer/blob/master/note/53%200%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-%20II.md)

**题目描述**
>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**输入输出**
>**输入:** [0,1,3]
**输出:** 2

>**输入:** [0,1,2,3,4,5,6,7,9]
**输出:** 8

---


[54二叉搜索树的第k大节点](https://github.com/Cenita/SwordPointOffer/blob/master/note/54二叉搜索树的第k大节点.md)

**题目描述**
>给定一棵二叉搜索树，请找出其中第k大的节点。

**输入输出**

>输入    :  root = [3,1,4,null,2], k = 1
```java
   3
  / \
 1   4
  \
   2
```
>输出   :    4


---
[55二叉树的深度](https://github.com/Cenita/SwordPointOffer/blob/master/note/55二叉树的深度.md)

**题目描述**
>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

**输入输出**
>给定二叉树 [3,9,20,null,null,15,7]，
```java
    3
   / \
  9  20
    /  \
   15   7
```
>返回它的最大深度 3 。



---
[55II平衡二叉树](https://github.com/Cenita/SwordPointOffer/blob/master/note/55II平衡二叉树.md)


**题目描述**
>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

**输入输出**

>样例一
给定二叉树 [3,9,20,null,null,15,7]
返回 true 。
```java
    3
   / \
  9  20
    /  \
   15   7
   ```


>样例二
给定二叉树 [1,2,2,3,3,null,null,4,4]
返回 false 。
```java
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
 ```


---




[56数组中数字出现的次数](https://github.com/Cenita/SwordPointOffer/blob/master/note/56I数组中数字出现的次数.md)

**题目描述**
>一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

**输入输出**
>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

>输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]

---




[56II数组中唯一只出现一次的数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/56II数组中唯一只出现一次的数字.md)

**题目描述**
>在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

**输入输出**
>输入：nums = [3,4,3,3]
输出：4

>输入：nums = [9,1,7,9,7,9,7]
输出：1
---




[57和为s的数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/57和为s的数字.md)

**题目描述**
>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

**输入输出**
>输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]

>输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]

---






[57II和为s的连续正数序列](https://github.com/Cenita/SwordPointOffer/blob/master/note/57II和为s的连续正数序列.md)


**题目描述**
>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

**输入输出**
>**输入**target = 9
**输出**[[2,3,4],[4,5]]

>**输入**target = 15
**输出**[[1,2,3,4,5],[4,5,6],[7,8]]
---






[58翻转字符串](https://github.com/Cenita/SwordPointOffer/blob/master/note/58翻转字符串.md)



**题目描述**
>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

**输入输出**
>输入: "`the sky is blue`"
输出: "`blue is sky the`"

>输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

>输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

---



[58 - II. 左旋转字符串](https://github.com/Cenita/SwordPointOffer/blob/master/note/58%20-%20II.%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md)

**题目描述**
>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。


**输入输出**
>**输入:** s = "abcdefg", k = 2
**输出:** "cdefgab"

>**输入:** s = "lrloseumgh", k = 6
**输出:** "umghlrlose"
---







[59 - I. 滑动窗口的最大值](https://github.com/Cenita/SwordPointOffer/blob/master/note/59%20-%20I.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.md)


**题目描述**
>给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**输入输出**
```java
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
 ```

---



[59 - II. 队列的最大值](https://github.com/Cenita/SwordPointOffer/blob/master/note/59%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.md)

**题目描述**
>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value 需要返回 -1


**输入输出**
```java
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

```java
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

---





[60n个骰子的点数](https://github.com/Cenita/SwordPointOffer/blob/master/note/60n个骰子的点数.md)


**题目描述**
>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

**输入输出**
```java
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```
```java
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

---



[61扑克牌中的顺子](https://github.com/Cenita/SwordPointOffer/blob/master/note/61扑克牌中的顺子.md)


**题目描述**
>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

**输入输出**
```java
输入: [1,2,3,4,5]
输出: True
```
```java
输入: [0,0,1,2,5]
输出: True
```

---




[62圆圈中最后剩下的数字](https://github.com/Cenita/SwordPointOffer/blob/master/note/62圆圈中最后剩下的数字.md)


**题目描述**
>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。


**输入输出**
```java
输入: n = 5, m = 3
输出: 3
```

```java
输入: n = 10, m = 17
输出: 2
```
---
[63股票利润最大值](https://github.com/Cenita/SwordPointOffer/blob/master/note/63股票利润最大值.md)

**题目描述**
>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

**输入输出**
```java
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
```java
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

---



[64求1+2+3+n](https://github.com/Cenita/SwordPointOffer/blob/master/note/64求1+2+3+n.md)

**题目描述**
>求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

**输入输出**
```java
输入: n = 3
输出: 6
```
```java
输入: n = 9
输出: 45
```

---




[65不用加法求和](https://github.com/Cenita/SwordPointOffer/blob/master/note/65不用加法求和.md)



**题目描述**
>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

**输入输出**
```java
输入: a = 1, b = 1
输出: 2
```

---
[66构建乘积数组](https://github.com/Cenita/SwordPointOffer/blob/master/note/66构建乘积数组.md)

**题目描述**
>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

**输入输出**
```java
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

---


[67把字符串转换成整数](https://github.com/Cenita/SwordPointOffer/blob/master/note/67把字符串转换成整数.md)


**题目描述**
>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明：
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

**输入输出**
```java
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```
```java
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

```java
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

```java
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

```java
输入: "42"
输出: 42
```
---

[68I二叉搜索树的最近公共祖先](https://github.com/Cenita/SwordPointOffer/blob/master/note/68I二叉搜索树的最近公共祖先.md)

**题目描述**
>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

**输入输出**
```java
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```
```java
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

---
[68II二叉树的最近公共祖先](https://github.com/Cenita/SwordPointOffer/blob/master/note/68II二叉树的最近公共祖先.md)

**题目描述**
>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
![输入图片描述](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

**输入输出**
```java
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```
```java
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```
